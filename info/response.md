# 目录和大纲自动更新原理与触发条件

## 1. 触发条件 (Trigger Conditions)

插件通过监听思源笔记的事件总线来实现自动更新。主要的触发事件是 **`loaded-protyle-static`**，即当文档内容在编辑器中加载完成（例如打开文档或切换文档）时触发。

在触发后，代码会进行以下**前置检查**，只有满足条件才会继续执行更新：
*   **非移动端**：在移动端设备上不会触发自动更新。
*   **非特殊视图**：
    *   不在**搜索**界面 (`search`)。
    *   不在**浮窗**或**完整显示**模式 (`showAll`) 下（具体取决于 `protyle.block.showAll` 属性）。

## 2. 更新原理 (Update Mechanism)

自动更新的核心逻辑在于**识别已存在的目录/大纲块**，读取其保存的配置，并重新生成内容进行覆盖。

### 目录 (Directory/Index) 更新流程：
1.  **查找标记块**：
    *   在当前加载文档的根节点下，通过 SQL 查询寻找包含 `custom-index-create` 属性的块。
    *   SQL: `SELECT * FROM blocks WHERE root_id = '${parentId}' AND ial like '%custom-index-create%' ...`
2.  **读取配置**：
    *   从找到的块的 IAL 属性中读取 `custom-index-create` 的值，这是一个 JSON 字符串，包含了生成该目录时的设置（如深度、列表类型等）。
    *   **关键检查**：检查配置中的 **`autoUpdate`** 选项。如果为 `false`，则终止更新。
3.  **重新生成与更新**：
    *   如果开启了自动更新，插件会根据读取到的配置，重新扫描笔记本结构 (`createIndex`) 生成新的 Markdown 内容。
    *   调用 `client.updateBlock` 接口，将新生成的 Markdown 内容更新到该块中，实现原地刷新。

### 大纲 (Outline) 更新流程：
1.  **查找标记块**：
    *   类似目录，通过 SQL 查询寻找包含 `custom-outline-create` 属性的块。
2.  **读取配置**：
    *   读取 `custom-outline-create` 中的配置。
    *   **关键检查**：检查配置中的 **`outlineAutoUpdate`** 选项。如果为 `false`，则终止更新。
3.  **重新生成与更新**：
    *   调用 `client.getDocOutline` 获取当前文档的最新大纲数据。
    *   根据配置（如是否引用、是否显示编号）生成 Markdown。
    *   调用 `client.updateBlock` 更新该块的内容。

## 3. 核心代码位置

*   **事件监听**: `src/index.ts` 中注册 `loaded-protyle-static` 事件监听 `updateIndex` 函数。
*   **入口判断**: `src/event/protyleevent.ts` 中的 `updateIndex` 函数负责初步筛选条件。
*   **核心逻辑**: `src/creater/createIndex.ts` 中的：
    *   `insertAuto`: 负责目录的自动更新逻辑。
    *   `insertOutlineAuto`: 负责大纲的自动更新逻辑。

## 4. 反向更新（列表 -> 文档树）的触发策略与构思

反向更新（即将列表的修改同步回文档属性或层级）操作风险较高，因为涉及对文件系统的写操作。为了避免“闪炸”（性能问题或数据冲突），必须谨慎选择触发时机。以下是几种推荐的触发策略：

### 策略一：显式触发 (Explicit Trigger) —— 最安全推荐
*   **触发方式**：在生成的目录/大纲块上方或右键菜单中，添加一个“**应用修改到文档树**” (Sync to Docs) 的按钮。
*   **机制**：用户可以随意编辑列表（重命名、拖拽排序），只有在确认无误后，点击按钮才一次性执行批量更新。
*   **优点**：
    *   **绝对安全**：完全避免了误操作和中间状态（正在打字时）的干扰。
    *   **性能友好**：不会占用后台资源监听输入。
*   **场景**：用户想对大纲进行大规模重构时。

### 策略二：防抖监听 (Debounced Monitoring) —— 体验较好
*   **触发方式**：监听编辑器的 `ws-main` 事务流，或者特定的 `input` 事件。
*   **机制**：
    1.  检测到用户正在编辑“目录块”内的内容。
    2.  启动一个 **防抖计时器 (Debounce Timer)**，时长建议 **3~5秒**。
    3.  如果用户还在打字，计时器重置。
    4.  只有当用户**停止操作超过设定时间**后，才执行解析和同步逻辑。
*   **优点**：接近实时的体验，只要用户不停下来思考就不会触发更新，避免了“打一个字刷新一次”的闪烁。
*   **注意**：需要加锁 (`isSyncing` 标志)，防止插件更新完列表后，又触发了新一轮的监听循环（死循环）。

### 策略三：焦点移出/保存时 (On Blur / Focus Out) —— 折中方案
*   **触发方式**：当用户的光标**离开**目录列表块，或者点击了文档的其他区域时触发。
*   **机制**：
    *   利用 `click-editorcontent` 全局事件，判断点击位置是否在目录块之外。
    *   如果在外部，且目录块有过修改（dirty flag），则执行同步。
*   **优点**：符合直觉，即“编辑完这里，去别的地方”代表编辑结束。
*   **缺点**：实现较为复杂，需要准确判断光标位置。

### 策略四：仅结构化变动 (Structure Change Only)
*   **触发方式**：只监听**拖拽 (Drag & Drop)** 或 **Tab/Shift+Tab (缩进)** 行为。
*   **机制**：
    *   忽略纯文本的修改（重命名）。
    *   当检测到列表项的位置发生变化（通过 `moveBlock` 事务）时，立即触发文档的移动或层级调整。
*   **优点**：针对性强，拖拽排序通常意味着明确的重组意图。

### 总结建议
考虑到思源笔记的插件环境，建议**首选“策略一：显式触发”**，因为它实现最简单且不出错。如果追求高级体验，可以尝试**策略二（防抖）**，但必须做好异常处理和循环防止。
